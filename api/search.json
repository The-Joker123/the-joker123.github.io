[{"id":"acd9aa7e47f3c4c4e5b4decd07b11489","title":"第二周","content":" 四、多变量线性回归(Linear Regression with Multiple Variables)\n 4.1 多维特征\n目前为止，我们探讨了单变量/特征的回归模型，现在我们对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为\n(x1,x2,...,xn)\\left( {x_{1}},{x_{2}},...,{x_{n}} \\right)\n(x1​,x2​,...,xn​)\n\n增添更多特征后，我们引入一系列新的注释：\nn：代表特征的数量n：代表特征的数量\nn：代表特征的数量\nx(i)代表第i个训练实例，是特征矩阵中的第i行，是一个向量（vector）。{x^{\\left( i \\right)}}代表第 i 个训练实例，是特征矩阵中的第i行，是一个向量（vector）。\nx(i)代表第i个训练实例，是特征矩阵中的第i行，是一个向量（vector）。\n比方说，上图的\nx(2)=[14163240]{x}^{(2)}\\text{=}\\begin{bmatrix} 1416\\\\ 3\\\\ 2\\\\ 40 \\end{bmatrix}\nx(2)=⎣⎢⎢⎢⎡​14163240​⎦⎥⎥⎥⎤​\nxj(i)代表特征矩阵中第i行的第j个特征，也就是第i个训练实例的第j个特征。{x}_{j}^{\\left( i \\right)}代表特征矩阵中第 i 行的第 j 个特征，也就是第 i个训练实例的第 j 个特征。\nxj(i)​代表特征矩阵中第i行的第j个特征，也就是第i个训练实例的第j个特征。\n如上图的x2(2)=3,x3(2)=2，如上图的x{2}^{\\left( 2 \\right)}=3,x{3}^{\\left( 2 \\right)}=2，\n如上图的x2(2)=3,x3(2)=2，\n支持多变量的假设h表示为：hθ(x)=θ0+θ1x1+θ2x2+...+θnxn，支持多变量的假设 h 表示为：h_{\\theta}\\left( x \\right)={\\theta_{0}}+{\\theta_{1}}{x_{1}}+{\\theta_{2}}{x_{2}}+...+{\\theta_{n}}{x_{n}}，\n支持多变量的假设h表示为：hθ​(x)=θ0​+θ1​x1​+θ2​x2​+...+θn​xn​，\n这个公式中有n+1个参数和n个变量，这个公式中有n+1个参数和n个变量，\n这个公式中有n+1个参数和n个变量，\n为了使得公式能够简化一些，引入x0=1，则公式转化为：hθ(x)=θ0x0+θ1x1+θ2x2+...+θnxn为了使得公式能够简化一些，引入x{0}=1，则公式转化为：h{\\theta} \\left( x \\right)={\\theta{0}}{x{0}}+{\\theta{1}}{x{1}}+{\\theta{2}}{x{2}}+...+{\\theta{n}}{x{n}}\n为了使得公式能够简化一些，引入x0=1，则公式转化为：hθ(x)=θ0x0+θ1x1+θ2x2+...+θnxn\n此时模型中的参数是一个n+1维的向量，任何一个训练实例也都是n+1维的向量，特征矩阵X的维度是m∗(n+1)。此时模型中的参数是一个n+1维的向量，任何一个训练实例也都是n+1维的向量，特征矩阵X的维度是 m*(n+1)。\n此时模型中的参数是一个n+1维的向量，任何一个训练实例也都是n+1维的向量，特征矩阵X的维度是m∗(n+1)。\n因此公式可以简化为：hθ(x)=θTX，其中上标T代表矩阵转置。因此公式可以简化为：h_{\\theta} \\left( x \\right)={\\theta^{T}}X，其中上标T代表矩阵转置。\n因此公式可以简化为：hθ​(x)=θTX，其中上标T代表矩阵转置。\n","slug":"第二周 1a5338e53ba880e190ddda94d3f5b5a7","date":"2024-08-15T11:50:36.000Z","categories_index":"吴恩达《机器学习》","tags_index":"机器学习","author_index":"曾阿喜"},{"id":"7b779fceee8e0bb3fffb044b06443f71","title":"Spring IOC","content":"Spring IOC一、谈谈你对Sping IOC的了解1.控制反转是一种思想，不是一个具体实现。\n2.IOC的思想就是将原本在程序中创建的控制权，交由Spring框架来管理。\n二、为什么叫控制反转？1.控制：指的是对象创建（实例化、管理）的权力\n2.反转：控制权交给外部环境管理（Spring框架，IOC容器）\n3.控制反转的重要软件设计思想就是，依赖倒置原则。\n4.什么是依赖倒置原则，假设我们设计一辆汽车，先设计轮子→底盘→车架，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。\n\n这样设计，可维护性很低。假设我们要把轮子尺寸增大，底盘设计就需要改，车身也需要改，同理汽车设计都需要改。\n5.现在我们换一种思路，我们先设计汽车的大概样子，轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。\n\n6.这就是依赖导致原则，把原本的高层建筑物“倒置”过来。高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。\n7.控制反转就是，依赖倒置原则的一种代码设计思路，具体采用的方法就是所谓的依赖注入\n\n7.为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class，车，车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下：\n\n\n💡 从上面代码可以看出，Car→Framework→Bottom→Tire\n\n\n\n8.把轮胎尺寸改成动态的\n\n为了让整个程序正常运行，我们需要做以下改动\n\n\n💡 由此我们可以看出，我们仅仅修改轮胎的尺寸，修改了整个上面画红色圈的的方法。软件工程中，**这样的设计几乎是不可维护。如果有几千个类的底层，如果每次修改这个类，我们都要修改所依赖的类，维护成本太高。**\n\n\n\n9.维护成本这么高，所以我们需要进行控制反转，及上层控制下层，而不是下层控制上层。\n所谓依赖注入就是，就是把底层作为参数传入上层类，实现上层控制下层。\n\n什么是控制反转容器(IoC Container)呢？其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。\n\n\n💡 因为采用了依赖注入，所以初始化时会写大量的new。这里就采用了IOC容器，来生成大量的初始化代码。我们只需要维护一个**Configuration。不用写大量的依赖注入的初始化代码。**\n\n\n\n10.IOC创建时我们不需要了解创建的细节是什么。下面这是我们自己手动创建的依赖注入的初始化代码。\n\n这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入。\n而IOC是反过来的，先从最上层开始向下找依赖关系，到达底层之后再往上一步一步new.\n\n这里IoC Container可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂：\n\n这就像工厂的客户，我们只需要了解工厂请求一个Car实例，按照配置自动生成。\n","slug":"SpringIOC","date":"2023-08-15T11:50:36.000Z","categories_index":"服务端","tags_index":"Spring","author_index":"曾阿喜"}]